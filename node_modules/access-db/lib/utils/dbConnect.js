"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.redisGetExpire = exports.redisExpire = exports.redisClient = exports.mongodb = exports.mongodbId = exports.mongodbCollection = exports.mysqlConnect = exports.mysqlPool = void 0;
const redis_1 = __importDefault(require("redis"));
const mysql_1 = __importDefault(require("mysql"));
const mongodb_1 = __importDefault(require("mongodb"));
/**
 *
 *  MYSQL_HOST=
 *  MYSQL_USER=
 *  MYSQL_PASSWORD=
 *  MYSQL_DATABASE=
 *  MYSQL_PORT=
 *  MYSQL_CONNECTION_LIMIT=
 *  MYSQL_CHARSET=
 */
//mysql 链接池
const pool = process.env.MYSQL_HOST ? mysql_1.default.createPool({
    connectionLimit: parseInt(process.env.MYSQL_CONNECTION_LIMIT || '10'),
    host: process.env.MYSQL_HOST,
    user: process.env.MYSQL_USER || 'root',
    password: process.env.MYSQL_PASSWORD || '123456',
    database: process.env.MYSQL_DATABASE,
    port: parseInt(process.env.MYSQL_PORT) || 3306,
    charset: process.env.MYSQL_CHARSET || 'UTF8_GENERAL_CI'
}) : null;
exports.mysqlPool = () => {
    return pool;
};
exports.mysqlConnect = (sql, sqlArr, callback) => {
    pool.getConnection((err, connection) => {
        if (err)
            throw new Error(JSON.stringify(err));
        connection.query(sql, sqlArr, callback);
        connection.release();
    });
};
/**
 *
 *  MONGODB_HOST=
 *  MONGODB_USER=
 *  MONGODB_PASSWORD=
 *  MONGODB_DATABASE=
 *  MONGODB_PORT=
 *
 */
// mongodb 连接
exports.mongodbCollection = (callback) => {
    if (!process.env.MONGODB_HOST)
        return null;
    let dbUri = 'mongodb://'
        + process.env.MONGODB_HOST + ':'
        + (process.env.MONGODB_PORT || '27017');
    if (process.env.MONGODB_USER) {
        dbUri = 'mongodb://'
            + process.env.MONGODB_USER + ':'
            + process.env.MONGODB_PASSWORD + '@'
            + process.env.MONGODB_HOST + ':'
            + (process.env.MONGODB_PORT || '27017');
    }
    mongodb_1.default.MongoClient.connect(dbUri, { useUnifiedTopology: true }, (err, client) => {
        if (err)
            throw new Error(JSON.stringify(err));
        let db = client.db(process.env.MONGODB_DATABASE);
        callback(db, client);
    });
};
exports.mongodbId = (id) => {
    let hex = /^[a-fA-F0-9]{24}$/;
    let tempId = (hex.test(id)) ? (new mongodb_1.default.ObjectID(id)) : id;
    return tempId;
};
exports.mongodb = process.env.MONGODB_HOST ? mongodb_1.default : null;
/**
 *
 */
// let client = redis.createClient(redisPort, redisAddress, { auth_pass: redisPassword });
let redisOptions = {
    host: process.env.REDIS_HOST,
    port: parseInt(process.env.REDIS_PORT) || 6379,
};
if (process.env.REDIS_AUTH_PASS) {
    redisOptions.auth_pass = process.env.REDIS_AUTH_PASS;
}
if (process.env.REDIS_PASSWORD) {
    redisOptions.password = process.env.REDIS_PASSWORD;
}
exports.redisClient = process.env.REDIS_HOST ? redis_1.default.createClient(redisOptions) : null;
// redisClient.on("error", function (err) {
//   console.log("Error " + err);
// });
exports.redisExpire = (key, time, type) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        if (type === 1) {
            exports.redisClient.expire(key, time, (err, reply) => {
                if (err)
                    reject(err);
                resolve(reply);
            });
        }
        else if (type === 2) {
            exports.redisClient.pexpire(key, time, (err, reply) => {
                if (err)
                    reject(err);
                resolve(reply);
            });
        }
        else if (type === 3) {
            exports.redisClient.expireat(key, time, (err, reply) => {
                if (err)
                    reject(err);
                resolve(reply);
            });
        }
        else if (type === 4) {
            exports.redisClient.pexpireat(key, time, (err, reply) => {
                if (err)
                    reject(err);
                resolve(reply);
            });
        }
    });
});
exports.redisGetExpire = (key, type) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        if (type === 1) {
            exports.redisClient.ttl(key, (err, reply) => {
                if (err)
                    reject(err);
                resolve(reply);
            });
        }
        else if (type === 2) {
            exports.redisClient.pttl(key, (err, reply) => {
                if (err)
                    reject(err);
                resolve(reply);
            });
        }
    });
});
