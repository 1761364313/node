var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const pTry = (fn, ...arguments_) => new Promise(resolve => {
    resolve(fn(...arguments_));
});
const pLimit = concurrency => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        throw new TypeError('Expected `concurrency` to be a number from 1 and up');
    }
    const queue = [];
    let activeCount = 0;
    const next = () => {
        activeCount--;
        if (queue.length > 0) {
            queue.shift()();
        }
    };
    const run = (fn, resolve, ...args) => __awaiter(this, void 0, void 0, function* () {
        activeCount++;
        // TODO: Get rid of `pTry`. It's not needed anymore.
        const result = pTry(fn, ...args);
        resolve(result);
        try {
            yield result;
        }
        catch (_a) { }
        next();
    });
    const enqueue = (fn, resolve, ...args) => {
        queue.push(run.bind(null, fn, resolve, ...args));
        (() => __awaiter(this, void 0, void 0, function* () {
            // This function needs to wait until the next microtask before comparing
            // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
            // when the run function is dequeued and called. The comparison in the if-statement
            // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
            yield Promise.resolve();
            if (activeCount < concurrency && queue.length > 0) {
                queue.shift()();
            }
        }))();
    };
    const generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));
    Object.defineProperties(generator, {
        activeCount: {
            get: () => activeCount
        },
        pendingCount: {
            get: () => queue.length
        },
        clearQueue: {
            value: () => {
                queue.length = 0;
            }
        }
    });
    return generator;
};
module.exports = pLimit;
